% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/check_keys.R
\name{fk_ish}
\alias{fk_ish}
\alias{assert_fk_ish}
\title{Check a tbl for a candidate foreign key constraint relationship}
\usage{
fk_ish(x, y, by = NA_character_,
  na_matches = pkgconfig::get_config("dplyr::na_matches"))

assert_fk_ish(x, y, by = NA_character_,
  na_matches = pkgconfig::get_config("dplyr::na_matches"))
}
\arguments{
\item{x}{data frame}

\item{y}{data frame with foreign key relationship to x}

\item{by}{character vector of key relationship, with semantics of dplyr join \code{by} parameters.}

\item{na_matches}{as in dplyr}
}
\value{
boolean whether \code{by} variables could specify a foreign key relationship \code{x}->\code{y}

Satisfying a foreign key constraint relationship would ensure that
\code{z <- dplyr::left_join(x, y, by = by)} would result in all rows of \code{x} appear in \code{z}.
A foreign key constraint requires two things:
\enumerate{
\item that all the key values in x be present in y
\item that key be pk_ish in y (e.g., distinct combinations)
Note: errors if the specified \code{by} is not present
Note 2: goal is to have a more flexible variable specification that can use \code{vars()} type spec (at least for same-named-key..)
Maybe the default arg should be NULL, not NA_character_ ?
}
}
\description{
Check a tbl for a candidate foreign key constraint relationship
}
\examples{
x <- tibble::tibble(id = c(1, 2, 3))
y <- tibble::tibble(id = c(1, 2, 3), val = c(100, 200, 300))
by <- "id"
fk_ish(x, y, "id")
x <- dplyr::band_members
y <- dplyr::band_instruments2
by <- c("name" = "artist")
library(nycflights13)
x <- flights
y <- airports
by <- c("dest" = "faa")
}
